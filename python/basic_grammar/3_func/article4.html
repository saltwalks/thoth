<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>article | Thoth</title>
    <link rel="stylesheet" href="../../font.css">
    <link rel="stylesheet" href="../../article_style.css">
  </head>
  <body>
    <header>
        <div id="logo"><a href="./index.html">Thoth</a></div>
    </header>
    <nav>
      <h1>함수선언</h1>
    </nav>
    <main>
      <h2>선언</h2>
      <ol>
        <li>기본구조 : <strong>def 함수명(매개변수1, 매개변수2, ... ):구현</strong></li>
        <li>구현부분은 <strong>반드시 줄을 바꿔서 인덴테이션을 넣고 해야된다</strong></li>
        <li>구현을 안하고싶다고 그냥 비워두면 안된다 : 그 이후의 코드를 함수의 내용으로 인식하고 인덴트가 안맞다고 에러를 발생기시기 때문</li>
        <li>따라서 이런 경우 <strong>pass</strong> 를 써주자</li>
      </ol>
      <h2>매개변수</h2>
      <ol>
        <li>타입 힌트 : <strong>def 함수이름(매개변수: 자료형) -> 자료형</strong></li>
        <ul>
          <li>파이썬은 동적 자료형 할당이기 때문에 보통 자료형을 명시하지 않지만 가독성을 높이기 위해 타입 힌트를 사용할 수 있다</li>
          <li><strong>변수에는 ": 자료형", 리턴값은 "-> 자료형"</strong>이렇게 적어준다</li>
          <li>하지만 자바처럼 엄격한 자료형 관리가 아닌 그냥 지키길 원한다는 가이드라인이어서 얼마든지 동적할당될 수 있으므로 주의해야한다</li>
          <li>변수에 ": 자료형" 이렇게 해주는거는 매개변수가 아닌 그냥 일반적인 변수 선언에도 사용 가능하다<strong>으지간하면 표시해주자</strong></li>
        </ul>
        <li><strong>매개변수명 앞에 *를 붙이면 입력한 인자들을 모아 튜플로 만든다</strong></li>
        <ul>
          <li>매개변수명[인덱스]로 호출 가능</li>
          <li>인자의 갯수를 모를때 활용하면 된다</li>
          <li>뭐 비스무리한 자료형이 아닌 튜플로 나오므로 iterate사용할 수 있다 - for문에 쓸 수 있다 이말이야</li>
          <li>*매개변수와 기본 매개변수를 전부 사용할 수 있다. 다만, 오해의 소지를 줄이기 위해 그냥 매개변수를 *매개변수의 앞에 두던가 인자를 입력할때 매개변수 이름=인자 기능으로 직접 넣어줘야한다</li>
          <li>통상적으로 매개변수명으로 arg를 쓴다(argument의 줄임말)</li>
        </ul>
        <li>키워드 파라미터 : **를 붙이면 딕셔너리가 된다</li>
        <ul>
          <li>선언할때 <strong>함수명(**매개변수명)</strong> 이래 해놓고</li>
          <li>함수 호출할때 <strong>함수명(인자1=값1, 인자2=값2, ... )</strong> 이렇게 호출하면</li>
          <li><strong>매개변수 = {"인자1":값1, "인자2":값2, ... }</strong> 이래 변환되고 <strong>매개변수["인자"]</strong> 이렇게 사용하면 된다</li>
          <li>입력한 인자가 문자열 형식으로 변환된다는거에 주의해라</li>
          <li>통상적으로 매개변수명으로 kwarg를 쓴다(keyword argument의 줄임말)</li>
        </ul>
        <li>인자를 안받아도 되는 매개변수</li>
        <ul>
          <li><strong>함수선언시에 (매개변수 = 초깃값)</strong>이렇게 선언하면 함수 호출시에 인자를 안넣어줘도 된다</li>
          <li>그럼 함수는 이 초깃값을 가지고 돌아가게 된다</li>
          <li>하지만 초기값을 사용하지 않고 다른값을 넣어주고 싶으면 <strong>함수 호출시에 (매개변수 = 값)</strong>이렇게 넣어주면 된다</li>
        </ul>
      </ol>
      <h2>리턴</h2>
      <ol>
        <li>튜플을 이용하면 리턴값을 여려개 보낼 수 있다</li>
        <ul>
          <li><strong>return 값1, 값2, ... </strong>일케 해주면 저 값들이 튜플로써 전달되게 된다 - 괄호없이 콤마만 쓰면 튜플이므로</li>
          <li>실질적으로는 튜플 하나만 반환하는것이므로 오류가 나지 않는다</li>
        </ul>
        <li><strong>튜플변수 = 반환값</strong> 이렇게 받을수도 있지만 <strong>변수1, 변수2, ... = 반환값</strong> 이런식으로도 변수에 각각 받아줄 수 있다</li>
      </ol>
      <h2>람다</h2>
      <ol>
        <li>lambda를 이용하면 한줄로 함수를 선언/구현할 수 있다</li>
        <ul>
          <li>기본구조 : <strong>함수명 = lambda 매개변수1, 매개변수2, ... : 구현</strong></li>
          <li>파이썬은 인덴트를 매우 중요하게 생각하므로 def를 사용하면 한줄로 끝낼 수 없다</li>
          <li>한줄로 끝낼 수 있는 간단한 함수를 구현할때 사용하면된다</li>
        </ul>
        <li>반환값으로 함수객체가 나오기 때문에 map이나 filter같은 함수형 기능을 사용할때 바로 인자로 집어넣을 수 있다</li>
      </ol>
      <h2>제네레이터</h2>
      <ol>
        <li>제네레이터는 어떤 많은 값들을 생성해서 사용해야할때 전부 다 만들어놓고 사용하는게 아닌 <strong>만드는 방법만 저장했다가 호출시에 바로바로 만들어 쓰는 개념</strong>이다</li>
        <li>대표적인예로 range()함수를 알아보자</li>
        <ul>
          <li>5조5억개의 숫자를 생성해야한다고 가정해보자</li>
          <li>이때 l1 = [n+1 for n in range(0, 오조오억)]으로 그냥 리스트를 생성하고</li>
          <li>l2 = range(0, 오조오억)이렇게 해줬을때 두가지는 인덱스로 접근도 가능하고, iterate도 사용할 수 있으니 같은 기능을 제공한다고 할 수 있다</li>
          <li>심지어 len()으로 요소의 갯수를 구해도 같은 값을 출력한다</li>
          <li>하지만 이 둘의 메모리 소모를 보면 확연히 차이가 난다 : l2가 현저히 적은 양의 데이터를 먹는다</li>
          <li>이것은 l1는 오조오억개의 숫자를 미리 만들어서 저장하고 있지만, l2의 경우에는 숫자를 생성하는 방법만 저장하고 실질적으로 만든 숫자는 가지고 있지 않다</li>
          <li>따라서 제네레이터는 같은 기능을 제공하지만 현저히 적은 메모리를 먹는다는 장점이 있다</li>
        </ul>
        <li>일반 함수에서 제네레이터 기능 사용하기 : yield</li>
        <ul>
          <li>return같은 경우에는 반환하면 바로 함수가 종료되지만 <strong>yield의 경우에는 종료되지 않는다</strong></li>
          <li>return같은 경우에는 반환값이 그대로 반환되지만 <strong>yield는 제네레이터 객체가 반환된다</strong></li>
          <li><strong>next(반환된 제네레이터 객체)를 이용해 다음으로 함수가 반환할 값을 그때그때 받아서 쓸 수가 있다</strong></li>
          <li>이것도 return의 경우에는 값을 다 만들어서 반환하지만 yield의 경우에는 값을 만드는 방법을 저장했다가 <strong>next()로 호출할때마다 그때그때 값을 만들기 때문</strong>이다</li>
        </ul>
      </ol>
    </main>
    <footer>
      copyright©saltwalks2021
    </footer>
  </body>
</html>

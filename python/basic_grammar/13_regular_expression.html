<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>article | Thoth</title>
    <link rel="stylesheet" href="../../font.css">
    <link rel="stylesheet" href="../../article_style.css">
  </head>
  <body>
    <header>
        <div id="logo"><a href="./index.html">Thoth</a></div>
    </header>
    <nav>
      <h1>정규표현식</h1>
    </nav>
    <main>
      <h2>용어정리</h2>
      <ol>
        <li>매칭된다 : 문자열의 특정 부분이 주어진 정규식의 조건에 부합하여 검거하는 것</li>
        <li>메타문자의 소비 : 정규식의 조건으로 기능을 하고 <strong>검거된 결과에도 그 메타문자가 지칭하는 것이 포함되어서 나오면 소비를 한다고 한다</strong></li>
        <ul>
          <li><strong>하지만 소비를 하지 않는 메타문자의 경우에는 정규식의 조건으로 기능은 하지만 결과에는 포함되어 나오지 않는다</strong></li>
          <li>예를들어, 소비하는 메타문자인 \s의 경우에는 검거결과에도 whitespace가 포함되어 나온다</li>
          <li>하지만 소비하지 않는 메타문자인 \b의 경우에는 검거결과에도 whitespace등이 포함되어 나오지 않는다</li>
        </ul>
      </ol>
      <h2>문자클래스 : []</h2>
        <ol>
          <li><strong>[abc] : a, b, c 중 하나라도 갖고있는 문자열 검거</strong> - ass(O), hole(X)</li>
          <li>모든 문자를 []안에 넣을 수 있지만 얘네 둘은 다른 의미를 가진다 : '-', '^'</li>
          <ul>
            <li><strong>'-' : from-to의 의미이다. 즉, [0-5]는 [012345]와 같다</strong></li>
            <li><strong>'^' : not의 의미이다. 즉, [^0123]이면 0123중 하나라도 가지고있으면 매칭되지 않는다</strong></li>
            <li>얘네 둘 뺴고는 모두 해당 문자가 포함되어있는지를 확인한다. <strong>이후에 여러 기호들이 많이 나오게 되는데 []안에 들어가있으면 무적권 이 기호 그 자체를 찾는거지 정규식의 의미를 갖지 않는다</strong></li>
          </ul>
          <li>자주사용하는 것들은 백슬래시 정규식으로 이미 만들어놨다</li>
          <ul>
            <li><strong>\d : digit. 숫자와 매치된다. [0-9]와 같다</strong></li>
            <li><strong>\s : space. 띄어쓰기나 줄바꿈 등의 눈에 안보이는 문자들과 매치된다</strong></li>
            <li><strong>\w : word. 단어와 매치된다. 즉, 숫자 혹은 알파벳으로 구성돼있으면 매치된다. [0-9a-zA-Z]와 같다</strong></li>
            <li><strong>얘네들을 대문자로 쓰면 제외하라는 반대 의미가 된다</strong>즉, \D는 [^0-9]와 같다</li>
          </ul>
        </ol>
      <h2>문자 대체 : '.'</h2>
      <ol>
        <li><strong>a.b : a와 b사이에 \n가 아닌 문자가 들어있는놈 검거</strong> - abc(O), ab(X)</li>
        <ul>
          <li>무슨말이냐 하면 a.b 일케 해주면 a와 b 사이에 \n가 아닌 문자가 하나라도 들어있으면 매치된다</li>
          <li>즉, .은 \n이외의 어떠한 문자도 될 수 있는 와일드카드다 이말이다</li>
          <li>만약 \n도 넣고싶다면 정규식을 컴파일할때 정규식과 같이 re.DOTALL을 인자로 넣어주면 된다</li>
        </ul>
      </ol>
      <h2>반복 : '*', '+', {}, ?</h2>
      <ol>
        <li><strong>ab*c : a와 c사이에 b가 0번 이상 반복해서 등장하면 검거</strong> - ac(O), abc(O), abbc(O), adc(X)</li>
        <li><strong>ab+c : a와 c사이에 b가 1번이상 반복해서 등장하면 검거</strong> - ac(X), abc(O), abbc(O), adc(X)</li>
        <li><strong>ab{2,5}c : a와 c사이에 b가 2번~5번 반복해서 등장하면 검거</strong> - abc(X), abbbc(O)</li>
        <ul>
          <li>슬라이싱때와 마찬가지로 앞뒤의 인자를 생략할 수도 있다. <strong>앞을 생략하면 0, 뒤를 생략하면 무한대</strong></li>
        </ul>
        <li><strong>ab?c : a와 c사이에 b가 0번 혹은 1번 반복해서 등장하면 검거(즉, {0,1}와 같음)</strong> - ac(O), abbc(X)</li>
      </ol>
      <h2>or연산 : |</h2>
      <ol>
        <li><strong>abc|def : abc나 def둘 중 하나가 들어간 놈을 찾는다</strong></li>
      </ol>
      <h2>문자열의 맨앞이나 맨끝만 조사하기 : ^, $, \A, \Z</h2>
      <ol>
        <li><strong>^abc : 문자열이 abc로 시작하나 조사한다</strong></li>
        <ul>
          <li>[]에서의 ^와 헷갈리지말자 : []에서의 ^는 "포함하지 않는"이고 그냥 ^는 맨앞을 조사하라는 의미이다</li>
        </ul>
        <li><strong>abc$ : 문자열이 abc로 끝나나 조사한다</strong></li>
        <li><strong>\Aabc : ^와 같으나 컴파일시 re.MULTILINE을 무시한다</strong></li>
        <li><strong>abc\Z : 마찬가지로 $와 같으나 컴파일시 re.MULTILINE을 무시한다</strong></li>
      </ol>
      <h2>단어경계부분 조사 : \b</h2>
      <ol>
        <li>단어경계란 : 단어는 <strong>알파벳과 숫자의 조합</strong>으로 정의된다. 따라서 단어경계는 <strong>단어와 단어 사이 알파벳과 숫자가 아닌 부분</strong>이라고 생각할 수 있을 것이다</li>
        <li>\babc\b : 단어 abc를 찾는다</li>
        <li>\B는 반대로 단어경계가 아닌 단어 내부를 조사한다. 즉, <strong>\Babc\B : 단어 속에 들어있는 abc를 찾는다</strong></li>
      </ol>
      <h2>그루핑 : ()</h2>
      <ol>
        <li>()를 통해 문자 여러개를 묶을 수 있다</li>
        <li><strong>(abc)+ : abc+는 abccc같은놈을 검거하지만 (abc)+는 abcabcabc같은놈을 검거한다</strong></li>
        <li>그루핑을 이용하면 ()의 내용만 소비할 수 있다. 즉, 검거한 전체 문자열이 아닌 ()의 내용만 가져올 수 있다</li>
        <ul>
          <li>정규식의 일부분을 ()로 묶으면 왼쪽에서 오른쪽으로, 다중으로 묶여있으면 밖에서 안으로 그루핑 인덱스가 매겨진다</li>
          <li>매치객체의 메소드 중 group()은 이 검거된 문자열 전체를 소비할 수도 있지만 그루핑 인덱스 별로 소비할 수 있게 해주기도 한다</li>
          <li><strong>매치.group(), 매치.group(0) : 검거된 문자열 전체를 소비한다</strong></li>
          <li><strong>매치.group(n) : n번 인덱스로 그루핑된 내용을 소비한다</strong></li>
          <li>그루핑한 문자열을 재참조 할 수도 있다. 즉, 동일한 내용의 정규식을 여러번 적고자 할 때 귀찮게 다 적을 필요 없이 <strong>\숫자 이렇게 해주면 '숫자'번째 인덱스의 그룹이 그대로 복붙되는 효과</strong>가 된다</li>
          <li>확장구문 (?어쩌고)를 이용하면 숫자 인덱스가 아닌 이름을 정해줄 수도 있다. <strong>(?P<이름>정규식) : 해당 정규식을 '이름'으로 그루핑한다. 재참조할때는 (?P=이름)이렇게 해주면 된다</strong></li>
        </ul>
      </ol>
      <h2>전방탐색</h2>
      <ol>
        <li><strong>긍정전방탐색 - (?=정규식) : 정규식과 부합하는 내용이 검거된다</strong></li>
        <li><strong>부정전방탐색 - (?!정규식) : 정규식과 부합하지 않는 내용이 검거된다</strong></li>
        <li>긍정/부정 탐색으로 검거된 내용은 기본적으로 소비되지 않는다. 즉, <strong>조건에는 포함되지만 검거결과로 나오지는 않는다 이말이다</strong></li>
      </ol>
      <h2>정규식 활용</h2>
      <ol>
        <li>정규식을 사용하기 위해선 그냥 사용하는게 아니고 <strong>컴파일을 먼저 해야 한다 : re.compile('정규식')</strong></li>
        <ul>
          <li>re는 모듈 이름으로 import re 해줘야된다</li>
          <li>컴파일을 하면 정규식 패턴 객체라는 것이 나온다. <strong>"패턴" 은 정규식을 컴파일한 결과이다</strong></li>
        </ul>
        <li>re.compile이 반환하는 정규식 패턴 객체가 제공하는 메소드들</li>
        <ul>
          <li><strong>패턴.match(문자열) : 문자열의 맨앞부분([:n]슬라이싱)이 정규식에 부합하는지 검사해 match객체로 반환한다</strong></li>
          <li><strong>패턴.search(문자열) : 문자열의 맨앞부분뿐만아니라 전부에 대해([n:m]슬라이싱) 정규식에 부합하는 부분이 있는지 검사해 match객체로 반환한다</strong></li>
          <li><strong>패턴.findall(문자열) : 문자열의 전부에 대해 정규식에 부합하는 모든 부분을 문자열 리스트로 반환한다</strong></li>
          <li><strong>패턴.finditer(문자열) : findall과 동일하지만 문자열 리스트가 아닌 match객체의 제네레이터를 번환한다</strong></li>
          <li><strong>패턴.sub(바꿀문자열, 타겟문자열) : 타겟문자열을 패턴으로 검거해 검거 결과들을 바꿀문자열로 바꾼다</strong></li>
        </ul>
        <li>패턴의 메소드가 반환하는 match객체가 제공하는 메소드들</li>
        <ul>
          <li><strong>매치.group() : 검거한 놈을 문자열로 반환한다</strong></li>
          <li><strong>매치.start() : 검거한 놈의 시작 인덱스를 반환한다</strong></li>
          <li><strong>매치.end() : 끝 위치를 반환한다. 항상 그렇듯이 끝나는 인덱스가 아닌 끝 인덱스+1이다</strong></li>
          <li><strong>매치.span() : (시작, 끝)튜플로 반환한다</strong></li>
        </ul>
        <li>자주 사용할 정규식은 패턴객체로 만들어 놓으면 여러번 컴하일하지 않아도 된다. 하지만 <strong>한번만 사용할 정규식은 그냥 re.패턴메소드(문자열)</strong> 이렇게 사용해도 된다</li>
        <li>컴파일할때 <strong>re.compile(정규식, 옵션)</strong>으로 옵션을 넣어줄 수 있다</li>
        <ul>
          <li><strong>re.DOTALL 혹은 re.S : .기호에 \n도 대체할 수 있도록 한다</strong></li>
          <li><strong>re.IGNORECASE 혹은 re.I : 대소문자를 구분하지 않고 검거한다</strong></li>
          <li><strong>re.MULTILINE 혹은 re.M : 패턴의 match()같은 메소드는 원래 문자열의 맨앞만 탐색하는데 이 옵션을 주면 줄바꿈 직후부분도 탐지한다</strong></li>
          <li><strong>re.VERBOSE 혹은 re.X : 정규식에 whitespace와 주석을 달 수 있게 해준다(컴파일시에는 무시한다). 따라서 정규식이 복잡할 경우 주석을 달아줄 수 있다</strong></li>
        </ul>
      </ol>
    </main>
    <footer>
      copyright©saltwalks2021
    </footer>
  </body>
</html>

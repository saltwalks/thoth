<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>article | Thoth</title>
    <link rel="stylesheet" href="../../font.css">
    <link rel="stylesheet" href="../../article_style.css">
  </head>
  <body>
    <header>
        <div id="logo"><a href="./index.html">Thoth</a></div>
    </header>
    <nav>
      <h1>정규표현식</h1>
    </nav>
    <main>
      <h2>용어정리</h2>
      <ol>
        <li>매칭된다 : 문자열의 특정 부분이 주어진 정규식의 조건에 부합하여 검거하는 것</li>
        <li>메타문자의 소비 : 정규식의 조건으로 기능을 하고 <strong>검거된 결과에도 그 메타문자가 지칭하는 것이 포함되어서 나오면 소비를 한다고 한다</strong></li>
        <ul>
          <li><strong>하지만 소비를 하지 않는 메타문자의 경우에는 정규식의 조건으로 기능은 하지만 결과에는 포함되어 나오지 않는다</strong></li>
          <li>예를들어, 소비하는 메타문자인 \s의 경우에는 검거결과에도 whitespace가 포함되어 나온다</li>
          <li>하지만 소비하지 않는 메타문자인 \b의 경우에는 검거결과에도 whitespace등이 포함되어 나오지 않는다</li>
        </ul>
      </ol>
      <h2>문자클래스 : []</h2>
        <ol>
          <li><strong>[abc] : a, b, c 중 하나라도 갖고있는 문자열 검거</strong> - ass(O), hole(X)</li>
          <li>모든 문자를 []안에 넣을 수 있지만 얘네 둘은 다른 의미를 가진다 : '-', '^'</li>
          <ul>
            <li><strong>'-' : from-to의 의미이다. 즉, [0-5]는 [012345]와 같다</strong></li>
            <li><strong>'^' : not의 의미이다. 즉, [^0123]이면 0123중 하나라도 가지고있으면 매칭되지 않는다</strong></li>
            <li>얘네 둘 뺴고는 모두 해당 문자가 포함되어있는지를 확인한다. <strong>이후에 여러 기호들이 많이 나오게 되는데 []안에 들어가있으면 무적권 이 기호 그 자체를 찾는거지 정규식의 의미를 갖지 않는다</strong></li>
          </ul>
          <li>자주사용하는 것들은 백슬래시 정규식으로 이미 만들어놨다</li>
          <ul>
            <li><strong>\d : digit. 숫자와 매치된다. [0-9]와 같다</strong></li>
            <li><strong>\s : space. 띄어쓰기나 줄바꿈 등의 눈에 안보이는 문자들과 매치된다</strong></li>
            <li><strong>\w : word. 단어와 매치된다. 즉, 숫자 혹은 알파벳으로 구성돼있으면 매치된다. [0-9a-zA-Z]와 같다</strong></li>
            <li><strong>얘네들을 대문자로 쓰면 제외하라는 반대 의미가 된다</strong>즉, \D는 [^0-9]와 같다</li>
          </ul>
        </ol>
      <h2>문자 대체 : '.'</h2>
      <ol>
        <li><strong>a.b : a와 b사이에 \n가 아닌 문자가 들어있는놈 검거</strong> - abc(O), ab(X)</li>
        <ul>
          <li>무슨말이냐 하면 a.b 일케 해주면 a와 b 사이에 \n가 아닌 문자가 하나라도 들어있으면 매치된다</li>
          <li>즉, .은 \n이외의 어떠한 문자도 될 수 있는 와일드카드다 이말이다</li>
          <li>만약 \n도 넣고싶다면 정규식을 컴파일할때 정규식과 같이 re.DOTALL을 인자로 넣어주면 된다</li>
        </ul>
      </ol>
      <h2>반복 : '*', '+', {}, ?</h2>
      <ol>
        <li><strong>ab*c : a와 c사이에 b가 0번 이상 반복해서 등장하면 검거</strong> - ac(O), abc(O), abbc(O), adc(X)</li>
        <li><strong>ab+c : a와 c사이에 b가 1번이상 반복해서 등장하면 검거</strong> - ac(X), abc(O), abbc(O), adc(X)</li>
        <li><strong>ab{2,5}c : a와 c사이에 b가 2번~5번 반복해서 등장하면 검거</strong> - abc(X), abbbc(O)</li>
        <ul>
          <li>슬라이싱때와 마찬가지로 앞뒤의 인자를 생략할 수도 있다. <strong>앞을 생략하면 0, 뒤를 생략하면 무한대</strong></li>
        </ul>
        <li><strong>ab?c : a와 c사이에 b가 0번 혹은 1번 반복해서 등장하면 검거(즉, {0,1}와 같음)</strong> - ac(O), abbc(X)</li>
      </ol>
      <h2>or연산 : |</h2>
      <ol>
        <li><strong>abc|def : abc나 def둘 중 하나가 들어간 놈을 찾는다</strong></li>
      </ol>
      <h2>문자열의 맨앞이나 맨끝만 조사하기 : ^, $, \A, \Z</h2>
      <ol>
        <li><strong>^abc : 문자열이 abc로 시작하나 조사한다</strong></li>
        <li><strong>abc$ : 문자열이 abc로 끝나나 조사한다</strong></li>
        <li><strong>\Aabc : ^와 같으나 컴파일시 re.MULTILINE을 무시한다</strong></li>
        <li><strong>abc\Z : 마찬가지로 $와 같으나 컴파일시 re.MULTILINE을 무시한다</strong></li>
      </ol>
      <h2>단어경계부분 조사 : \b</h2>
      <ol>
        <li>단어경계란 : 단어는 <strong>알파벳과 숫자의 조합</strong>으로 정의된다. 따라서 단어경계는 <strong>단어와 단어 사이 알파벳과 숫자가 아닌 부분</strong>이라고 생각할 수 있을 것이다</li>
        <li>\babc\b : 단어 abc를 찾는다</li>
        <li>\B는 반대로 단어경계가 아닌 단어 내부를 조사한다. 즉, <strong>\Babc\B : 단어 속에 들어있는 abc를 찾는다</strong></li>
      </ol>
      <h2>그루핑 : ()</h2>
      <ol>
        <li>()를 통해 문자 여러개를 묶을 수 있다</li>
        <li><strong>(abc)+ : abc+는 abccc같은놈을 검거하지만 (abc)+는 abcabcabc같은놈을 검거한다</strong></li>
        <li>그루핑을 이용하면 ()의 내용만 소비할 수 있다. 즉, 검거한 전체 문자열이 아닌 ()의 내용만 가져올 수 있다</li>
        <ul>
          <li>정규식의 일부분을 ()로 묶으면 왼쪽에서 오른쪽으로, 다중으로 묶여있으면 밖에서 안으로 그루핑 인덱스가 매겨진다</li>
          <li>매치객체의 메소드 중 group()은 이 검거된 문자열 전체를 소비할 수도 있지만 그루핑 인덱스 별로 소비할 수 있게 해주기도 한다</li>
          <li><strong>매치.group(), 매치.group(0) : 검거된 문자열 전체를 소비한다</strong></li>
          <li><strong>매치.group(n) : n번 인덱스로 그루핑된 내용을 소비한다</strong></li>
          <li>그루핑한 문자열을 재참조 할 수도 있다. 즉, 동일한 내용의 정규식을 여러번 적고자 할 때 귀찮게 다 적을 필요 없이 <strong>\숫자 이렇게 해주면 '숫자'번째 인덱스의 그룹이 그대로 복붙되는 효과</strong>가 된다</li>
          <li>확장구문 (?어쩌고)를 이용하면 숫자 인덱스가 아닌 이름을 정해줄 수도 있다. <strong>(?P<이름>정규식) : 해당 정규식을 '이름'으로 그루핑한다. 재참조할때는 (?P=이름)이렇게 해주면 된다</strong></li>
        </ul>
      </ol>
      <h2>전방탐색</h2>
      <ol>
        <li><strong>긍정전방탐색 - (?=정규식) : 정규식과 부합하는 내용이 검거된다</strong></li>
        <li><strong>부정전방탐색 - (?!정규식) : 정규식과 부합하지 않는 내용이 검거된다</strong></li>
        <li>긍정/부정 탐색으로 검거된 내용은 기본적으로 소비되지 않는다. 즉, <strong>조건에는 포함되지만 검거결과로 나오지는 않는다 이말이다</strong></li>
      </ol>
      <h2>Greedy한 메타기호란?</h2>
      <ol>
        <li>어떤 메타기호가 Greedy하다는 것은 이놈이 <strong>최대한 많은 문자들을 소비하려고 한다는 것이다</strong></li>
        <li>Greedy한 메타기호는 *와 +가 있다. 즉, 정규식 "a.*c"을 "abcabcabc"의 문자열에 대입하면 abc도 있지만 제일 많은양을 소비할 수 있는 "abcabcabc"를 소비하게 된다</li>
        <li>이것을 막으려면 *와 +뒤에 <strong>?를 붙여주는 것이다. 이것을 붙여주면 최대소비가 아닌 최소소비가 되어 제일 적은양을 소비하는 선택지를 검거</strong>할 것이다</li>
      </ol>
      <h2>백슬래시 메타기호를 쓸때 주의사항</h2>
      <ol>
        <li>파이썬은 \\를 자동으로 \로 변환한다. 따라서 메타기호가 아닌 문자로써의 \를 검거하기 위해 정규식에 \\이렇게 써봤자 \하나로 바뀌어서 메타기호로 인식하게 된다</li>
        <li>그렇다고 \\를 표현하기 위해 \\\\이렇게 4개를 쓸 수도 없는 일이다. 이때 raw string이라 것을 이용한다</li>
        <li><strong>문자열 앞에 r을 붙여주면 raw string이 된다. r"\\"를 쓰면 얘가 \ 하나로 자동변환하지 않고 그냥 냅두기 때문에 문자로써의 \를 사용할 수 있다</strong></li>
      </ol>
      <h2>헷갈릴 여지가 있는 놈들 정리</h2>
      <ol>
        <li>괄호 : [], {}, ()</li>
        <ul>
          <li>[] : 문자 클래스. 검거대상이 <strong>반드시 보유해야 하는 문자</strong>를 지정</li>
          <li>{} : 몇번 반복되야 검거할건지 그 <strong>검거 반복 횟수</strong>를 지정</li>
          <li>() : <strong>그루핑</strong></li>
        </ul>
        <li>^</li>
        <ul>
          <li>정규식 맨 앞에 등장하는 ^ : 문자열의 <strong>시작부분을 조사</strong>하라는 의미</li>
          <li>[]안에 들어있는 ^ : 검거대상이 <strong>보유하면 안되는 문자를 지정</strong></li>
        </ul>
        <li>?</li>
        <ul>
          <li>문자 뒤의 ? : {0,1}</li>
          <li>()안의 ? : 확장기호. P나 =, !와 같이 써서 그루핑 닉네임, 전방 긍정/부정 탐색 등의 의미를 가진다</li>
          <li>메타기호 뒤의 ? : 해당 메타기호를 non-greedy하게 동작하게 함</li>
        </ul>
      </ol>
      <h2>정규식 활용</h2>
      <ol>
        <li>정규식을 사용하기 위해선 그냥 사용하는게 아니고 <strong>컴파일을 먼저 해야 한다 : re.compile('정규식')</strong></li>
        <ul>
          <li>re는 모듈 이름으로 import re 해줘야된다</li>
          <li>컴파일을 하면 정규식 패턴 객체라는 것이 나온다. <strong>"패턴" 은 정규식을 컴파일한 결과이다</strong></li>
        </ul>
        <li>re.compile이 반환하는 정규식 패턴 객체가 제공하는 메소드들</li>
        <ul>
          <li><strong>패턴.match(문자열) : 문자열의 맨앞부분([:n]슬라이싱)이 정규식에 부합하는지 검사해 match객체로 반환한다</strong></li>
          <li><strong>패턴.search(문자열) : 문자열의 맨앞부분뿐만아니라 전부에 대해([n:m]슬라이싱) 정규식에 부합하는 부분이 있는지 검사해 match객체로 반환한다</strong></li>
          <li><strong>패턴.findall(문자열) : 문자열의 전부에 대해 정규식에 부합하는 모든 부분을 문자열 리스트로 반환한다</strong></li>
          <li><strong>패턴.finditer(문자열) : findall과 동일하지만 문자열 리스트가 아닌 match객체의 제네레이터를 번환한다</strong></li>
          <li><strong>패턴.sub(바꿀문자열, 타겟문자열) : 타겟문자열을 패턴으로 검거해 검거 결과들을 바꿀문자열로 바꾼다</strong></li>
        </ul>
        <li>패턴.sub() 메소드에 참조구문이나 함수 사용하기</li>
        <ul>
          <li><strong>/g<그루핑 인덱스> : 검거된 그룹을 인덱스 를 통해 참조할 수 있게 된다. 바꿀 문자열에 사용하면 타겟문자열을 인덱스가 가리키는 검거된 그룹으로 바꿀 수 있다</strong></li>
          <li><strong>바꿀문자열을 매치객체를 인자로 받는 함수로 넣어주면 타겟문자열의 검거 결과 매치객체들이 함수로 연산되어서 바뀌게 된다</strong></li>
        </ul>
        <li>패턴의 메소드가 반환하는 match객체가 제공하는 메소드들</li>
        <ul>
          <li><strong>매치.group() : 검거한 놈을 문자열로 반환한다</strong></li>
          <li><strong>매치.start() : 검거한 놈의 시작 인덱스를 반환한다</strong></li>
          <li><strong>매치.end() : 끝 위치를 반환한다. 항상 그렇듯이 끝나는 인덱스가 아닌 끝 인덱스+1이다</strong></li>
          <li><strong>매치.span() : (시작, 끝)튜플로 반환한다</strong></li>
        </ul>
        <li>자주 사용할 정규식은 패턴객체로 만들어 놓으면 여러번 컴파일하지 않아도 된다. 하지만 <strong>한번만 사용할 정규식은 그냥 re.패턴메소드(문자열)</strong> 이렇게 사용해도 된다</li>
        <li>컴파일할때 <strong>re.compile(정규식, 옵션)</strong>으로 옵션을 넣어줄 수 있다</li>
        <ul>
          <li><strong>re.DOTALL 혹은 re.S : .기호에 \n도 대체할 수 있도록 한다</strong></li>
          <li><strong>re.IGNORECASE 혹은 re.I : 대소문자를 구분하지 않고 검거한다</strong></li>
          <li><strong>re.MULTILINE 혹은 re.M : 패턴의 match()같은 메소드는 원래 문자열의 맨앞만 탐색하는데 이 옵션을 주면 줄바꿈 직후부분도 탐지한다</strong></li>
          <li><strong>re.VERBOSE 혹은 re.X : 정규식에 whitespace와 주석을 달 수 있게 해준다(컴파일시에는 무시한다). 따라서 정규식이 복잡할 경우 주석을 달아줄 수 있다</strong></li>
        </ul>
      </ol>
    </main>
    <footer>
      copyright©saltwalks2021
    </footer>
  </body>
</html>

<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>article | Thoth</title>
    <link rel="stylesheet" href="../../font.css">
    <link rel="stylesheet" href="../../article_style.css">
  </head>
  <body>
    <header>
        <div id="logo"><a href="./index.html">Thoth</a></div>
    </header>
    <nav>
      <h1>다중자료형</h1>
    </nav>
    <main>
      <h2>리스트</h2>
      <ol>
        <li>리스트 요소 추가 = append(<strong>요소 하나</strong>), +=[리스트], extend(<strong>리스트</strong>), insert(<strong>인덱스, 요소</strong>)</li>
        <ul>
          <li>+=와 extend는 기능이 같다</li>
          <li>요소 추가에는 조건이 따른다. <strong>요소가 추가되는 리스트는 특정한 변수에 저장되어 참조될 수 있어야 한다</strong> 즉, [1, 2, 3, 4].append(5)는 안된다는 소리다</li>
        </ul>
        <li>리스트 요소 삭제 = del 리스트이름[<strong>인덱스</strong>], remove(<strong>요소 하나</strong>), pop() : <strong>맨 마지막 팦</strong></li>
        <li>리스트 문자열로 만들기 = <strong>"요소들을 연결할 문자".join(리스트)</strong></li>
        <li>파이썬의 리스트는 다른 리스트들과는 좀 다르다</li>
        <ul>
          <li>c나 자바의 경우에는 리스트에 요소로 들어갈 자료형의 정수배를 하여 리스트의 메모리를 할당한다</li>
          <li>이 경우에는 연속된 메모리 공간에 인덱스 순서대로 리스트의 요소가 저장되므로 인덱스를 지정하면 간단한 연산만으로 메모리 주소를 알 수 있어 매우 빠르다</li>
          <li>하지만 이 경우에는 리스트에 같은 자료형의 요소만 저장할 수 있고 선언된 리스트의 크기를 넘어서면 에러가 발생하는 등 불편한 점이 있다</li>
          <li>하지만 파이썬은 속도를 양보하고 편의성을 가져왔다. 즉, 파이썬의 경우 연속된 메모리 공간에 리스트의 요소를 저장하지 않는다</li>
          <li>파이썬에서는 요소들의 주소를 하나의 배열로 관리하는 형식을 취하며, 요소가 추가되면 리스트의 다음 공간에 추가하는 방식이 아닌 추가된 요소의 주소를 주소배열에 넣어주는 방식이다</li>
          <li>이 방식은 새로 요소가 추가되면 요소를 메모리 어딘가에 할당하고 이것의 주소를 주소배열에 연결해주고, 요소가 삭제되면 주소배열과 요소와의 연결을 끊어주는 방식으로 요소 추가와 삭제가 이루어진다</li>
          <li>이 방식의 장점은 기술한대로 편리함에 있다. 실제로 요소들이 차지하는 메모리 공간은 단순한 특정 자료형의 정수배가 아니기 떄문에, <strong>리스트에 다양한 자료형을 추가해도 문제가 되지 않는다</strong></li>
          <li>또한 리스트의 크기가 제한적이지 않으며 언제든 <strong>리스트의 크기를 늘리거나 줄일 수 있다</strong>는 장점이 있다</li>
          <li>하지만 <strong>단점은 기술한 대로 속도</strong>이다. 주소배열이 저장하고 있는 주소들은 반드시 인덱스 순서대로라고 할 수 없다. 요소가 추가되면 주소배열의 빈공간에 그냥 넣어주고 삭제되면 그 요소가 차지하던 주소배열의 자리를 그냥 비워주면 되기 때문이다</li>
          <li>따라서 간단한 인덱스를 통한 값 조회의 경우에도 모든 주소배열의 주소로 들어가 값과 데이터타입, 요소들이 저장하고 있는 인덱스 값을 비교해야 되므로 단순한 연산으로 끝나지 않게 된다</li>
        </ul>
        <li>리스트 대소비교 : 리스트도 문자열처럼 <strong>앞의 인덱스에 있는 값이 클수록 높은 우선순위</strong>를 가진다. </li>
      </ol>
      <h2>튜플</h2>
      <ol>
        <li>튜플은 기본적으로 선언 후에는 변경이 불가능하다</li>
        <ul>
          <li>+=연산자를 통해 요소 추가가 되는것처럼 보이지만 실제로는 추가가 아닌 추가된 튜플을 새로 만드는 거임(주소값이 다르다)</li>
        </ul>
        <li><strong>튜플의 요소가 한개여도 콤마(,)를 찍어준다</strong> – (1,)처럼</li>
      </ol>
      <h2>딕셔너리</h2>
      <ol>
        <li>기본구조 : {키1:값1, 키2:값2 ... }</li>
        <li>딕셔너리의 리스트화</li>
        <ul>
          <li>Keys() : 딕셔너리의 키들만 모아 리스트로 만듦</li>
          <li>Values() : 마찬가지임</li>
          <li>Items() : 마찬가지임. 다만 키-밸류 쌍을 튜플로 묶어 리스트를 만듦</li>
          <li>!!주의 : 이 값들을 이용해 불러낸 값들은 리스트 객체로 나오지 않는다. List() 생성자를 이용해 리스트로 바꿔줘야만 리스트가 되며 그 전까지는 <strong>dict_라는 값이 붙은 객체로 나오게 됨</strong>. 얘네들은 iteration까진 되지만 추가, 삭제 등의 변경이나 여타 리스트의 연산들은 안된다는 점을 주의할것</li>
        </ul>
        <li>기본적으로 딕셔너리의 <strong>키들은 바뀌면 안되기 때문에 불변객체로 선언해줘야 한다</strong> 즉, 리스트를 키로 선언할수는 없다는 얘기다</li>
        <li>딕셔너리 get() 함수 : 딕셔너리[키] 연산과 동일하지만 존재하지 않는 키의 경우 <strong>get()함수는 오류가 아닌 none</strong> 값을 출력한다는 차이가 있다</li>
        <li><strong>딕셔너리의 입력 순서는 유지될 수도 있고 아닐 수도 있다</strong> : 3.7버전 이상부터는 입력순서가 유지되도록 자체 인덱스를 가지게 수정되어있지만 그 이전의 버전에서는 이것을 지원하지 않는다. 따라서 입력순서가 유지될거라고 생각하고 코딩하는것은 위험한 일이다</li>
        <ul>
          <li>입력순위가 유지되는 딕셔너리가 꼭 필요한 경우에는 하위버전과의 호환성을 위해 OrderedDict객체를 이용하자</li>
        </ul>
        <li>defaultdict객체 : <strong>딕셔너리변수 = collections.defaultdict(value의 자료형)</strong></li>
        <ul>
          <li>이놈은 <strong>존재하지 않는 키를 참조할떄 KeyError가 아닌 디폴트값을 기준으로 키와 벨류 쌍을 생성해준다</strong></li>
          <li>예를들어 딕셔너리[존재하지 않는 키] = 어떤 값 이렇게 주면 그 즉시 {"존재하지 않는 키":"어떤 값"}이렇게 추가가 된다</li>
          <li>디폴트 값은 어떤 값을 주는게 아닌 갑자기 연산을 떄릴 경우를 위해 존재한다</li>
          <li>예를들어, 일반적인 딕셔너리에 딕셔너리[존재하지 않는 키] += 2 이지랄 해버리면 키:벨류 쌍에 없는 키를 참조하는데 거기다가 2를 더하라는 황당하기 그지없는 명령일 것이다</li>
          <li>하지만 defaultdict의 경우에는 그 "존재하지 않는 키"의 벨류로 정수형의 디폴트값인 0을 할당해서 키:벨류 쌍을 만들고, 거기다가 2를 더해서 {"존재하지 않는 키":2}라는 키:벨류 쌍을 만들어준다</li>
          <li>얘는 물론 type이 dict는 아니다. type검사를 해보면 defaultdict라는 객체로 나오긴 하나 dict와 동일한 기능 + 상기한 추가적인 기능을 제공한다 - 딕셔너리를 래핑(wrapping)한 객체라고 부른다</li>
        </ul>
        <li>counter 객체 : <strong>리스트나 튜플을 인자로 {인자의 요소:그요소가 인자 내에 몇개 있는지}의 딕셔너리를 반환한다</strong></li>
        <ul>
          <li>예를들면 1이 2개, 3이4개, 5가6개 존재하는 리스트를 인자로 넣어주면 {1:2, 3:4, 5:6}이렇게 딕셔너리로 만들어서 반환한다</li>
          <li>물론 이것도 순수한 딕셔너리는 아니고 counter라는 객체로 래핑한 객체이다</li>
          <li>most_common(숫자)의 함수를 이용하면 빈도 수가 높은 리스트의 요소 순위(conter객체에서 벨류값이 높은 순위)를"숫자"순위 까지 보여준다</li>
        </ul>
      </ol>
      <h2>집합</h2>
      <ol>
        <li>이 두가지 특징만 기억해라</li>
        <ul>
          <li><strong>집합은 키 없는 딕셔너리</strong>와 같다. 키도 없고 인덱스도 없음. 즉, <strong>집합의 요소들에 개별적으로 접근할 수 있는 방법이 없다</strong> = 접근은 생성자를 이용해 리스트 등으로 바꾼 담에야 가능.</li>
          <li>중복된 요소들을 가질 수 없다 : 리스트, 튜플 등을 집합으로 변경하면 중복된 값이 다 사라진다 = 중복제거 알고리즘으로 이용 가능</li>
        </ul>
        <li>수학에서의 집합과 동일한 특성을 가진다. 따라서 수학에서의 집합연산도 가능하다</li>
        <ul>
          <li>교집합 : &, intersection()</li>
          <li>합집합 : |, union()</li>
          <li>차집합 : -, difference()</li>
        </ul>
        <li><strong>집합의 요소도 불변객체여야 한다</strong>즉, 리스트를 집합으로 묶을 수 없다 이말이다</li>
      </ol>
      <h2>괄호 정리!</h2>
      <ol>
        <li>문자열 : ‘#’, “#", ‘’’#‘’’, “””#“””</li>
        <li>리스트 : [ ]</li>
        <li>튜플 : ( ), 없음(콤마만)</li>
        <li>딕셔너리 : { }</li>
        <li>집합 : { } – 중괄호 안에 요소들이 키값이 없으면 집합인거</li>
      </ol>
      <h2>자료형(객체)복사</h2>
      <ol>
        <li>'=' 연산은 객체 복사가 아닌 참조할당이다(메모리를 아끼기 위해서인듯)</li>
        <li><strong>객체 복사를 위해서는 copy()나 생성자를 이용</strong>하자</li>
        <ul>
          <li>단, 앞에서 말한거처럼 튜플은 copy()나 생성자를 통해 만들어도 어차피 같은놈이고 변경도 안되므로 <strong>튜플은 메모리를 하나만 할당</strong>한다</li>
          <li>copy()함수는 copy모듈을 import해야 한다</li>
        </ul>
        <li>다중구조에서의 복사 : deepcopy()</li>
        <ul>
          <li>리스트 안에 리스트가 있거나 뭐 튜플이 있거나 하는 다중 구조의 경우에는 copy()를 써도 안에 있는 놈은 참조할당된다</li>
          <li><strong>따라서 안에있는놈까지 복사하고싶은경우에는 deepcopy()를 써서 복사해야된다</strong></li>
          <li>물론 이놈도 copy모듈을 import해야한다</li>
        </ul>
      </ol>
      <h2>변수 여러개를 한번에 선언/초기화하고싶나?</h2>
      <ol>
        <li>리스트 이용하기 : [변수1, 변수2, ... ] = [값1, 값2, ... ]</li>
        <li>튜플 이용하기 : 변수1, 변수2, ... = 값1, 값2, ...</li>
        <li>물론 튜플에 괄호넣어도 된다 : (변수1, 변수2, ... ) = (값1, 값2, ... )</li>
      </ol>
    </main>
    <footer>
      copyright©saltwalks2021
    </footer>
  </body>
</html>
